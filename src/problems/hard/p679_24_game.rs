/// 679. 24 Game
///
/// 給定一個長度為4的正整數陣列 nums，你需要用 +、-、*、/ 四種運算符
/// 和括號將這四個數字連接起來，使得最終結果等於24。
///
/// 注意：
/// - 除法運算是真除法，不是整數除法
/// - 每個數字必須用且只能用一次
/// - 可以使用括號改變運算順序
/// - 如果可以得到24，返回 true；否則返回 false
///
/// 示例 1：
/// 輸入：nums = [4, 1, 8, 7]
/// 輸出：true
/// 解釋：(8-4) * (7-1) = 4 * 6 = 24
///
/// 示例 2：
/// 輸入：nums = [1, 2, 1, 2]
/// 輸出：false
///
/// 限制條件：
/// - nums.length == 4
/// - 1 <= nums[i] <= 9

#[allow(dead_code)]
pub fn judge_point24(nums: Vec<i32>) -> bool {
    todo!("實現 24 Game 的解決方案 - 請先理解題目和測試案例")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_judge_point24() {
        // 示例 1: [4, 1, 8, 7] -> true
        // (8-4) * (7-1) = 4 * 6 = 24
        assert_eq!(judge_point24(vec![4, 1, 8, 7]), true);
        
        // 示例 2: [1, 2, 1, 2] -> false
        assert_eq!(judge_point24(vec![1, 2, 1, 2]), false);
        
        // 額外測試用例
        // [1, 1, 8, 8] -> true
        // (8 / 8 + 1) * 1 * 24 = 24 (錯誤，重新計算)
        // (1 + 1 + 8) * 8 / 4 = 24 (無4)
        // 8 / (1 - 1/8) = 8 / (7/8) = 64/7 ≠ 24
        // 實際: (8-1+1)*8/8 = 8, 不對
        // 正確: 8/(1-1/8) 無法用給定數字實現
        // 讓我們用一個確定的例子: (1+1)*8+8 = 24
        assert_eq!(judge_point24(vec![1, 1, 8, 8]), true);
        
        // [3, 3, 8, 8] -> true  
        // 8/(3-8/3) = 8/(9/3-8/3) = 8/(1/3) = 24
        assert_eq!(judge_point24(vec![3, 3, 8, 8]), true);
        
        // [1, 1, 1, 1] -> false
        // 無論如何運算都無法得到24
        assert_eq!(judge_point24(vec![1, 1, 1, 1]), false);
        
        // [2, 2, 2, 2] -> false  
        // 2+2+2+2=8, 2*2*2*2=16, 都不等於24
        assert_eq!(judge_point24(vec![2, 2, 2, 2]), false);
        
        // [6, 6, 6, 6] -> false
        // 6+6+6+6=24 但需要三個加號，我們只能用兩個運算符處理四個數
        // 實際上: 6+6+6+6確實=24，但在我們的運算規則下需要驗證
        // (6+6)+(6+6) = 12+12 = 24，這是可行的
        assert_eq!(judge_point24(vec![6, 6, 6, 6]), true);
    }
    
    #[test]
    fn test_edge_cases() {
        // 包含1的情況 - 實際上 [1,2,3,4] 可以得到24: (1+2+3)*4 = 6*4 = 24
        assert_eq!(judge_point24(vec![1, 2, 3, 4]), true);
        
        // 大數字情況
        assert_eq!(judge_point24(vec![9, 9, 9, 9]), false);
        
        // 混合數字
        assert_eq!(judge_point24(vec![1, 3, 4, 6]), true); // 6/(1-3/4) = 6/(1/4) = 24
        
        // 確實無解的情況
        assert_eq!(judge_point24(vec![1, 1, 2, 2]), false);
    }
}
